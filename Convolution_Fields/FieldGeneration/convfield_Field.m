function cfield = convfield_Field( lat_data, Kernel, derivtype,resadd,...
                                   lat_masked, enlarge )
                                               
% CONVFIELD_FIELD( lat_data, Kernel, resadd, derivtype, enlarge )
% generates an object of class Field containing the convolution field
% derived from lattice data smoothed with a seperable kernel.
% The generated field is evaluated on an equidistant grid with resolution
% increased by adding resadd voxels inbetween each voxel in each dimension.
%--------------------------------------------------------------------------
% ARGUMENTS
% Mandatory
%  lat_data  an object of class Field with fiberD == 1.
%  Kernel    either an object of class SepKernel or a numeric.
%            If class SepKernel:
%              if derivtype = 0: the fields 'kernel' and 'truncation' must
%                                be specified.
%              if derivtype = 1: the fields 'dkernel' and 'dtruncation'
%                                must be specified.
%              if derivtype = 2: the fields 'd2kernel' and 'd2truncation'
%                                must be specified.
%
%            If Kernel is numeric, the convolution field is generated by 
%            smoothing with an isotropic Gaussian kernel with FWHM = Kernel.
%            Truncation and adjust_kernel are set to be default values.
% Optional
%  derivtype  0/1/2, 0 returns the convolution field, 1 its derivative
%             and 2 its second derivative (at all points). Default is 0
%             i.e to return the field. Note that if D > 1, then derivtype = 2
%             has not yet been implemented.
%  resadd     the amount of voxels added equidistantly in between the
%             existing voxels. Default is 1.
%  lat_masked a logical, if true lat_data is masked by the provided mask in
%             the lat_data Field object.  
%  enlarge    a numeric which must be a positive integer or zero. The
%             convolution field is computed on a domain enlarged in each
%             direction by 'enlarge' voxels. Note if resadd ~=0 the added
%             voxels are in high resolution. Default 0. 
%--------------------------------------------------------------------------
% OUTPUT
%  cfield   an object of class ConvField representing the field obtained by
%           smoothing the lat_data field object by the Kernel object.
%--------------------------------------------------------------------------
% EXAMPLES
%--------------------------------------------------------------------------
% AUTHOR: Fabian Telschow, Samuel Davenport                                            
%--------------------------------------------------------------------------

%% Check mandatory input
%--------------------------------------------------------------------------

% Check the lat_data input
if ~iscompletefield( lat_data )
    error( "lat_data must be a complete object of class Field." )
elseif lat_data.fiberD ~=1
    error( "The fiber dimension needs to be 1." )
else
    % Get dimension of the input data
    D = lat_data.D;
    % Get size of the mask of input data
    Dim = lat_data.masksize;
    % Get number of subjects
    nsubj  = lat_data.fibersize;
    % Get the xvals
    xvals  = lat_data.xvals;
    % Index for multidimensional coding
    indexD = repmat( {':'}, 1, D );
end

% Check the Kernel input
if isnumeric( Kernel )
    % If Kernel is numeric use an Gaussian Kernel
    Kernel = SepKernel( D, Kernel );

elseif ~isa( Kernel, 'SepKernel' )
    % If Kernel is neither numeric nor of class SepKernel, output an error
    error( strcat( "The 'Kernel' must be either a numeric or an ",...
                   "object of class SepKernel." ) );
end

%% Add/check optional values
%--------------------------------------------------------------------------

%%% lat_masked input
if ~exist( 'lat_masked', 'var' )
    lat_masked = true;
end

%%% resadd input
% Add resolution increase if missing
if ~exist( 'resadd', 'var' )
    resadd = 1;
end

% Get the difference between voxels with resolution increase
dx = NaN * ones( [ 1 D ] );
for d = 1:D
    dx(d) = xvals{d}(2)-xvals{d}(1);
end
dx_hr = dx ./ ( resadd + 1 );

% Reject input, if resadd is to large in 3D
if D == 3 && ( resadd > 18 )
    error( 'In 3D you shouldn''t use such high resolution for memory reasons' )
end

%%% derivtype input
if ~exist( 'derivtype', 'var' )
    derivtype = 0;
end

%%% enlarge input
if ~exist( 'enlarge', 'var' )
    enlarge = ceil( resadd / 2 );
end

%% Main function
%--------------------------------------------------------------------------

%%% Mask the lat_data if necessary
if lat_masked && ~lat_data.masked
    lat_data = Mask( lat_data );
end

%%% Get resolution increased size of the domain
% Dimensions for domain of the field with increased resolution
Dimhr = ( Dim - 1 ) * resadd + Dim; % Dimhr = Dim with high resolution

% Modify Dimhr by adding enlarge voxels to all sides
if enlarge ~= 0 
    if D == 1
        Dimhr = Dimhr + 2 * enlarge * [ 1, 0 ];
    else
        Dimhr = Dimhr + 2 * enlarge;
    end
end

%%% Expand lattice to new high resolution by filling in zeros
% Create index to fill the original data at the correct voxels of the high
% resolution data array
index = cell( [ 1 D ] );
for d = 1:D
    index{d} = ( enlarge + 1 ):( resadd + 1 ):( Dimhr(d) - enlarge );
end

% Increase the resolution of the raw data by introducing zeros
expanded_lat_data = squeeze( zeros( [ Dimhr, nsubj ] ) );
expanded_lat_data( index{:}, : ) = lat_data.field;

%%% Prepare output of class Field
% Create a ConvField class object with high resolution mask
cfield = ConvField();
% Fill the properties
cfield.kernel    = Kernel;
cfield.enlarge   = enlarge;
cfield.resadd    = resadd;
cfield.derivtype = derivtype;
cfield.mask      = mask_highres( lat_data.mask, resadd, enlarge );
xvals2 = cell( [ 1, D ] );
for d = 1:D
    xvals2{d} = ( xvals{d}(1) - enlarge * dx_hr(d) ) : dx_hr(d) : ...
                                    ( xvals{d}(end) + enlarge * dx_hr(d) );
end
cfield.xvals = xvals2;

%%% Main loop: calculation of convolution fields
if D < 4
    % run the smoothing using fconv
    if derivtype == 0
        % calculates the convolution field
        cfield.field = fconv( expanded_lat_data, Kernel.kernel, D,...
                              Kernel.truncation(1), dx_hr, Kernel.adjust );
        
    elseif derivtype == 1        
        % preallocate the output field for speed
        smooth_data = ones( [ Dimhr(1:D), nsubj, D ] );
        
        % Get the gradient object of the Kernel
        dKernel = Gradient( Kernel );
        
        % Calculates the derivatives of the convolution field
        for d = 1:D
            smooth_data(indexD{:},:,d) = fconv( expanded_lat_data,...
                                                 dKernel{d}.kernel, D, ...
                                                 dKernel{d}.truncation,...
                                                 dx_hr, dKernel{d}.adjust );
        end
        
        % Fill the derivatives into the cfield output
        cfield.field = smooth_data;
        
    elseif derivtype == 2
        % preallocate the output field for speed
        smooth_data = ones( [ Dimhr(1:D), nsubj, D, D ] );
        
        % Get the Hessian object of the Kernel
        Kernel = Hessian( Kernel );
        
        % Calculates all second derivatives of the convolution field
        for d = 1:D
           for dd = 1:D
                smooth_data(indexD{:},:,d,dd) = fconv( expanded_lat_data,...
                                                 Kernel{d,dd}.kernel, D, ...
                                                 Kernel{d,dd}.truncation,...
                                                 dx_hr, Kernel{d,dd}.adjust );
           end
        end
        
        % Fill the derivatives into the cfield output
        cfield.field = smooth_data;
        
    else
        error( 'Higher derivatives than 2 are not supported' )  
    end
    
else
    error('D != 1,2,3 has not been implemented yet!')
end

return